# -*- coding: utf-8 -*-
__author__ = "C.Wilhelm"
__license__ = "AGPL v3"

from lxml import etree

"""
Views (includes Forms, Tables)
- presentation-layer for database contents
- handle labels for columns and the model itself
- aliases are handled as if they were to be translated
"""
class _View(object):
	__command__ = None # may get generated if __model__ is set
	__model__ = None # ignored if __command__ is set
	_fields = [] # if empty, use every field except _exclude
	_exclude = [] # ignored if _fields is empty

class FieldSetMeta(type):
	@classmethod
	def __prepare__(metacls, name, bases, **kwargs):
		return OrderedDict()
	def __init__(cls, name, bases, attrs):
		# FieldSets, FieldGroups shall not contain hidden-fields or buttons
		# TODO: put all grandchild-fields into grand-father's Form obj
		cls._name = name
		cls._fields = []
		for objname,obj in attrs.items():
			if hasattr(obj, "_handled_by_fieldset") and obj._handled_by_fieldset:
				obj._name = objname
				cls._fields.append(obj) # if isclass(obj): # FieldSet needs to be instantiated
		# it might be a subclass of another Form/FieldSet, so we have
		# to either prepend or append them (theyre already sorted)
		# TODO: some comparable thing might be possible with Models?
		for baseclass in bases:
			if hasattr(baseclass, "_fields"):
				for fieldobj in baseclass._fields:
					if fieldobj._name not in attrs: # could be overridden
						fc = copy(fieldobj)
						cls._fields.append(fc) # will be affected by bind_form()
						setattr(cls, fc._name, fc)
		return type.__init__(cls, name, bases, attrs)
	def reorder_fields(cls, *names):
		# intended to be called for forms generated by __command__
		# may be all about putting in different FieldSet objects
		pass

"""One Form can have multiple FieldSets. A Form is a FieldSet.
While Form classes exists once globally, they spawn a distinct object per request"""
class FieldSet(_View):# python3: Form(list, metaclass=FieldSetMeta):
	__metaclass__ = FieldSetMeta
	__labelstr__ = "" # label for HeaderHolder(Form) or FieldSet-label
	__inline__ = True # until now UniForm specific, shall be generic
	_form = None # bind_form() shall set it / Form._parent is always None
	_handled_by_fieldset = True
	def bind_form(self, formcls):
		# problem: in case of Form, we operate on a class,
		# while in case of FieldSet, we operate on object(s)
		handle_bind_form(self, formcls)
	def append_fields(self, *fields):
		# should only be called from within bind_form(), in order to get
		# them recognized and not to have each field's bind_form() by hand
		for obj in fields:
			# e.g. let FieldGroup be customizable to be rendered as FieldSet
			if isclass(obj): # FieldSet needs to be instantiated
				raise Exception("only objects shall be added through append_fields()") # obj = obj()
			self._fields.append(obj)
		return self
	def label(self, string):
		"""the label on the submit button, the default is 'Save Changes'"""
		self.__labelstr__ = string
		return self
	def clean(self, formobj):
		for field in self._fields:
			field.clean(formobj)
		return self
	def validate(self, formobj):
		success = True
		for field in self._fields:
			tf_response = field.validate(formobj)
			if tf_response != True:
				if tf_response != False: # FieldGroup/Fieldset.validate() may return False
					formobj._errors[field._name] = tf_response
				success = False
		return success
	def __element__(self, formobj):
		# return the fieldset element, may be called recursively
		# only the Form object stores _errors, _values and handles hidden-fields, buttons
		fieldset = etree.Element("fieldset")
		if self.__labelstr__ not in ("",None):
			# CSS: sub-fieldsets shall be rendered differently
			legend = etree.SubElement(fieldset, "legend")
			legend.text = self.__labelstr__
		if self.__inline__:
			fieldset.attrib["class"] = "inlineLabels" # __DI
		# render errorMsg in topmost fieldset (Form)
		if hasattr(self,"_values") and len(formobj._errors) > 0:
			errordiv = etree.SubElement(fieldset, "div", {"id":"errorMsg"})
			h3 = etree.SubElement(errordiv, "h3")
			h3.text = "Please check the following Fields:"
			ol = etree.SubElement(errordiv, "ol")
			for fieldname, errormsg in formobj._errors.iteritems():
				li = etree.SubElement(ol, "li")
				li.text = str(errormsg) + fieldname
		# populate from _fields
		for field in self._fields:
			# field could be _Field, FieldGroup, FieldSet
			fieldset.append(field.__element__(formobj))
		return fieldset

class FormMeta(FieldSetMeta):
	"""Form Fields can be generated from a Command"""
	def __init__(cls, name, bases, attrs):
		## generate fields from __command__, add em to attrs
		cls._generate_fields(attrs)
		# while FieldSetMeta only handles _Field objects,
		# FormMeta takes care of Buttons, HiddenFields, etc
		# FieldSetMeta must not have Buttons, HiddenFields?
		FieldSetMeta.__init__(cls, name, bases, attrs)
		#cls._fields = ... # already filled by FieldSetMeta
		cls._form = cls
		cls._buttons = [] # button-fields don't need to have bind_form() called
		# some hiddenfields need to be instanciated per object, as their values
		# are handled within their objects!!!
		# maybe handle [values of] hidden-fields as part of temporary_fields ??
		cls._hidden_fields = []
		for objname,obj in attrs.iteritems():
			if hasattr(obj, "_handled_by_fieldset") and not obj._handled_by_fieldset:
				obj._name = objname
				if isinstance(obj, HiddenField):
					cls._hidden_fields.append(obj)
				else: # (Submit)Button
					cls._buttons.append(obj)
		# _bound_fields are filled by handle_bind_form()
		cls._bound_fields = [] # fields with _column not beeing None
		handle_bind_form(cls,cls)
	def _generate_fields(cls, attrs):
		"""Data-centric approach: populate attrs based on commands' column objects"""
		cmdobj = attrs.get("__command__", None)
		if cmdobj is None:
			return
		elif not isinstance(cmdobj, (command.Update,command.Insert)):
			raise Exception("command must be one of Insert or Update (instead of %s)" % type(cmdobj).__name__)
		dropped_cols = [] # will eventually contain PrimaryKey columns
		for c in cmdobj.relevant_columns:
			if c._is_pk: # wait.... PK?
				if isinstance(cmdobj, command.Update):
					pass
				# sparse PrimaryField objects from form and Command
				dropped_cols.append(c)
				continue
			tfield = c._renderclass(c)
			setattr(cls, c._name, tfield)
			attrs[tfield._name] = tfield
		cmdobj.drop_columns(*dropped_cols)

class Form(FieldSet):
	"""generic forms builder using pyratemp templates
	centralizes all layouting measures - e.g. taking care of generating valid XHTML
	a list of values gets filled on creation: either via SQL, POST-/GET, or pre-set.
	alhrough it enables to take whatever database backend, it does not verbose any
	database internals, such as table names, etc."""
	__metaclass__ = FormMeta
	__command__ = None # the _fields list shall may filled by this, each object shall operate on a copy
	__populate__ = None # will be generated object-wise, if not overridden, based on __command__
	__fields__ = [""] # column/field names that will be part of the form (whitelist, ordered)
	__exclude__ = [""] # fields not to be part of the form (blacklist)
	__tokenstr__ = "_token" # this will be the field's name for the security token __DI
	_nosession_token = ""
	_validators = [] # hole-form validators may get defined here
	@property
	def _bound_to_update(self)
		return self.__populate__ is not None
	def __init__(self, htparams = {}, session = {}, **attrib):
		"""
		when using this function, it should have got obvious, that the form WEREN'T successfully sent already,
		so put put everything together in a <form> and append hints - if there are any - to each field they represent
		usage:
			command:	Command object to generate a Form object from (optional, see examples)
			htparams:	dict-like object holding HTTP parameters (highly appreciated)
			session:	dict-like session object, your framework should provide one (needed to prevent CSRF)
		furthermore, the <form> tag can be extended due serialization of **attributes:
			id:			will be the id-attribute of the entire form, might be of use for layouting and js
			action:		specifies the action attribute of the formular. e.g.: <form action="">
						usually the base-http handler, e.g. "index" - think as of a target of submission
			method:		http-method, either "get" or "post"
		"""
		# make shure, action-attribute is set #attributes["action"] = action
		if "action" not in attrib:
			raise Exception("Form.__init__(): it ís required to specify the 'action' attribute")
		# default accept-charset to "utf8" and method-attribute to "get"
		if "method" not in attrib:
			attrib["method"] = "post"
		if "accept-charset" not in attrib:
			attrib["accept-charset"] = "utf-8"
		self.attrib = attrib # shall hold the html attributes for the initial <form> tag
		# only this coppy should be accessed from Form objects
		if self.__class__.__command__ is not None:
			self.__command__ = self.__class__.__command__.__copy__() # need thread-safety
		if self.__populate__ is None and isinstance(self.__command__, command.Update):
			# needs to be generated per Form object, too (think of different where clauses)
			# TODO: we need a simpler way to let changes on __command__ have an effect on __populate__!!
			# for now, it is o.k. to generate it HERE instead of in __init__()
			self.__populate__ = self.__command__.dbo._adapter.Select(self.__command__)
		self._htparams = htparams # shall hold all formular data evenually sent
		self._session = session
		self._values = {} # will be the mapping for Command.commit() TODO: state, e.g. cleaned, filled_by_htparams/select()
		self._temporary_fields = {} # needed for RadioButtonGroup: fieldgroup_name:_fields[]
		self._hidden_fields = self.__class__._hidden_fields[:] # some HiddenField objects need to be created on-demand (e.g. Token)
		#self._values_prefetched = {} # filled to be able to compare with htparams (only on UPDATE)
		self._errors = {}
		self._values_ready = False # set to True if either clean() has run or values are fetched from db
	def onsuccess(self):
		# there will be no value for unselected checkboxes and radiobuttons - defaults to None
		## There will allways be fields, that are not to be inserted into the database,
		## such as old-password for PasswordFieldGroup
		## TODO: handle None: replace ""/defaultstr with None
		if self.__command__ is not None:
			commit_values = {}
			for column_name in self.__command__.relevant_column_names:
				value = self._values.get(column_name)
				#if value in ("",None) and self._bound_to_update and "require" not in field._validators:
				#	# if command is Update and field is not required, it should not be added
				#	# this is true for Password fields, in other cases it is meant to overwrite with None
				#	# TODO: clean/adapt_type shall take care of that!!!!!
				#	continue
				commit_values[column_name] = value
			# TODO: need a proper aliases-system for both Form and Table
			TESTSTR = str(dict(commit_values))
			try:
				TESTSTR += "<br><br>" + str(self.__command__)
				### ### # ### self.__command__.commit(**self._values)
				return "Changes where written successfully: " + TESTSTR
			except:
				raise
		return "valid"
	def __str__(self):
		# if obfuscasion is active, use ids/names according to aliases 
		# a) when rendering and b) when validating/commiting -> moved to extra class
		# token are meant to prevent double-form-submissions; XSRF
		TESTSTR = str(dict(self._values))
		# maybe maintain 3 lists: renderble_fields, all_fields, relevant_for_command_fields
		sent_token = self._htparams.pop(self.__tokenstr__, None)
		expected_token = self._session.get(self.__tokenstr__, self._nosession_token)
		if sent_token is not None: # form has been submitted
			# TODO: make this a validator for the hole form
			if sent_token != expected_token:
				return 'error: double form submission <a href="">go back to form</a>'
			## evaluate form based on those values
			# _values must not be empty before validate() gets called
			if self.validate():
				return self.onsuccess()
		elif self._bound_to_update:
			## Formular was not sent ar all => populate _values from SELECT
			self._values = self.__populate__.fetch_dict()[0]
		## generate TOKEN - requires session to be set
		if self._session is not None: # TODO: len(self._session) > 0: # session required for token
			tokenvalue = base64.b64encode(os.urandom(11))[:11]
			self._session[self.__tokenstr__] = tokenvalue
		else: # if no session is set, use default string
			tokenvalue = self._nosession_token
		self._hidden_fields.append(HiddenField(name=self.__tokenstr__, value=tokenvalue))
		## add hiddenfields for everything in htparams -> TODO: consider how to make that customized
		#for key,value in self._htparams.iteritems():
		#	self._hidden_fields.append(HiddenField(name=key, value=value))
		return etree.tostring(self.__element__(), encoding="UTF-8", method="html", pretty_print=True) + TESTSTR + str(self._errors)
	def clean(self):
		"""prepare Form._values to contain objects with the right type (e.g. after Submission)"""
		# clean() will merge values from _htparams into _vaues
		return FieldSet.clean(self,self)
	def validate(self):
		"""returns True, if the form was submitted AND all validators returned boolean True
		returns False, if something went wrong, after having filled the _errors dictionary"""
		# validate() shall be called only once per request, as clean() is called every time
		# it might be neccessary to do clean(), even if value was fetched (e.g. Adapter or dbapi didn't
		# take care of typecasting)
		# TODO: maybe handle token here?!
		self.clean() # "clean" all input data, should do nothing if it happened already
		# handle hole-form validators - removed (fill self._errors[NAME?])
		# handle per-field validators, return boolean
		return FieldSet.validate(self,self)
	def __element__(self):
		self.attrib["class"] = "uniForm" # __DI
		formroot = etree.Element("form", self.attrib)
		fieldset = FieldSet.__element__(self,self)
		# autogenerated hidden fields (note, that some have been set manually within _fields)
		for field in self._hidden_fields:
			fieldset.append(field.__element__(self))
		# buttons: if manually defined, use them instead of autogenerated one
		div = etree.Element("div", {"class":"buttonHolder"}) # __DI
		if len(self._buttons) == 0: # add default Submit-Button
			self._buttons = [SubmitButton(value="Save Changes")]
		for button in self._buttons:
			div.append(button.__element__(self))
		fieldset.append(div)
		formroot.append(fieldset)
		return formroot

###########################################################################
######################## _Field Classes ################################
######################################################################## */

"""
bo = BooleanColumn()
CheckBox(bo).render()
"""

#class _Field(object):# FieldInterface, as this is the brich between Data and EndUser
class _Field(object):
	"""abstract class for formular fields, it shall be only used to subclass it"""
	_instantiation_count = 0 # SYNC W/ BaseColumn
	_handled_by_fieldset = True # False for HiddenField and Submit-Buttons
	_hint = "" # TODO: hint(), default(), readonly()/ disabled()
	#attrib = None # will hold all html-attributes in an OrderedDict
	# options are handled through the options() method
	#validators = [] # will hold all validators, will be the same as from columns and handled only there
	# formfield-relevant information needed in templates
	#multiline = False # for TextArea, this will be True, needed in templates TODO: ashure
	#triminput = False # True at least for Email and Password
	_validators = [] # while a list is easy to override, the object will hold a local dict (!)
	_name = property(
		fget = lambda self:self.attrib.get("name",""),
		fset = lambda self,value:self.attrib.__setitem__("name",value) if "name" not in self.attrib else None,
		fdel = lambda self:self.attrib.__delitem__("name"),
		doc = "_name property is internally handled as part of attrib - does not override if name does exist!!"
	)
	def __init__(self, column = None, **attrib):
		self._validators = dict((v._name, v) for v in self.__class__._validators)
		self._form = None # assigned by bind_form()
		self.__optionsobj = [] # only to be messed with by the options() and _options() methods !
		self.attrib = attrib
		self._column = column
		if column is not None:
			if not hasattr(column, "_pytype"):#isinstance(column, BaseColumn):
				raise TypeError("_Field.__init__(): first parameter must be an instance of BaseColumn or None")
			self._name = column._name
			if column._choices is not None:
				self.options(column._choices) # bootstrap options
		# label will be autoguessed in case of beeing empty
		# label can be changed manually by label() method and aligned using label_left() and label_right()
		# label beeing None means there is no label at all
		self.labelstr = ""
		self.labelleft = True
		# Field is newly created, some things aren't needed on convertion
		self._instantiation_count = _Field._instantiation_count # held actual value locally
		_Field._instantiation_count += 1 # increment class-wide attribute for next instantiation
		#etree.ElementBase.__init__(self, attrib=attrib)
		# errors, hints, success are handled in the Form-class
		# by default, value will be taken from Form._htparams, ignoring attrib["value"]
		# _init() is called from bind_form(), so the formCLASS will be known
	def _value_py(self, formobj):
		# _values needs are to be prepared via clean()
		return formobj._values.get(self._name)
	def _value_str(self, formobj):
		# usualy forwarded to Column._value_str()
		# might be overridden in order to do more/less
		value = self._value_py(formobj)
		if self._column is not None:
			return self._column._prepare_value(value)
		elif value is None:
			return "" # some Column classes may handle that otherwise
		return str(value)
	def _has_error(self, formobj):
		return self._name in formobj._errors
	def clean(self, formobj):
		# __element__ does take formobj as parameter and graps all values needed (usually one)
		# for fields, that have no _column set, values must be given with appropriate types
		# FieldSet/FieldGroup: clean() shall subsequently call each columns clean()
		# within __element__, error means fieldname is part of _error.keys()
		original = formobj._htparams.get(self._name, "")
		if self._column is not None:
			formobj._values[self._name] = self._column._adapt_value(original)
		else: # needs to be taken care of manually, then!!!
			formobj._values[self._name] = original
		return self
	def validate(self, formobj):
		value = formobj._htparams.get(self._name, None)
		response = True
		for validator in self._validators.itervalues():
			response = validator(self, formobj)
			if response != True:
				# as only one errormsg is possible per field,
				# the order of validators might be important !
				# e.g. whether a field is required should be checked first
				break
		return response
	def required(self, is_required = True):
		"""shortcut to set/unset the "required" validator"""
		if is_required:
			self.append_validators(validators.required())
		else:
			del self._validators["required"]
		return self
	def append_validators(self, *validators):
		"""append validator(s) to the internal dict of validators"""
		# by storing validators in a dict, it is handled if validateMaxLength(12)
		# gets added when maxlength(22) was already set before
		# Form objects: it is possible to have multiple validateSameAs() validators!
		for v in validators:
			self._validators[v._name] = v
		# resort by priority (e.g., required should be checked first)
		return self
	def append_css(self, class_str):
		# will add a string to attrib["class"] (or set it if it didn't exist)
		if "class" not in self.attrib:
			self.attrib["class"] = class_str
		else:
			self.attrib["class"] += " " + class_str
		return self
	def bind_form(self, formcls):
		#if self._form is not None:
		#	raise Exception("bind_form() may be called only once")
		self._form = formcls
		# perfect moment to finalize label, as label() could have been called after __init__()
		if self.labelstr in (None,""):
			if self._column is not None:
				if self._column._reference is not None: # FOR FOREIGN KEYS, USE THE TABLES NAME
					self.labelstr = self._column._reference._table._name
				else:
					self.labelstr = self._column._name
			else:
				self.labelstr = self._name
			# split by "_" and capitalize TODO: make configurable, e.g. by overriding some method
			self.labelstr = " ".join(s.capitalize() for s in self.labelstr.split("_"))
		# _init gets overridden by subclasses => make shure, _fields get filled only once
		if hasattr(self, "_fields") and len(self._fields) > 0:
			return self
		##### CALL -init() FROM HERE #####
		self._init()
		##### Always set class-attribute with values from BaseValidator.__css__()
		# neither the set of validators nor the "class"-attribute shall be changed after _init()
		for validator in self._validators.itervalues():
			newcls = validator.__css__()
			if newcls != "":
				self.append_css(newcls)
		return self
	"""def bind_name(self, newname):
		doesn't overwrite, like setting the self._name property would do
		# unique-id vs. accessibility
		# setting an id by default would make it hard to make shure, that
		# the ID is unique throughout the entire html
		# but: ids are used to associate a <label> with an <input>
		# decision: set _id on demand (when setting "for", see __element__()
		if "name" not in self.attrib:
			self._name = newname
		return self"""
	def options(self, options):
		"""options can be
			a Model object or a Select (will be taken care of in _options())
			list of {label:value} assignments like {'Apples': 1, 'Oranges': 2} / [("Apples",1),("Oranges",2)]
			an OrderedDict object - note that it is dict[value] = key!
		by default, boolean Columns have those two options: [("Yes",True),("No",False)]
		-> You might overwrite these options to e.g. [("Active",True),("Inactive",False)]"""
		self.__optionsobj = options
		return self
	def _options(self):
		# __optionsobj gets in shape HERE, thus staying in sync with
		# database changes and preventing overhead if not needed
		# __optionsobj can be either a Table, a Select obj or something
		# that can be converted into a dict (e.g.: a dict)
		# TODO: would be a good place to enable i18n
		# Step #1: generate Select object in case __optionsobj is a Table object
		if hasattr(self.__optionsobj, "_relationships"):#isinstance(o, database.Model):
			model = self.__optionsobj
			repr_col = model._representing_column
			pkey_col = model._primary_keys[0]
			selectobj = model.select(repr_col, pkey_col).orderby(repr_col)
			self.__optionsobj = selectobj
		# Step #2: this way, we don't have to repeat Step #1 when called twice
		if isinstance(self.__optionsobj, command.Select):
			return OrderedDict(self.__optionsobj.fetch_raw())
		# Step #3: this is the most usual case, anyway!
		return OrderedDict(self.__optionsobj)
	def __repr__(self):
		return object.__repr__(self).replace('object', "'%s'"%self._name)
	############# label specific #############
	def label(self, string):
		"""label: assumed not beeing None, it is the text of the label to this field"""
		self.labelstr = string
		return self
	def label_left(self):
		self.labelleft = True
		return self
	def label_right(self):
		self.labelleft = False
		return self
	############ readonly and disabled #########
	def _readonly(self):
		return "readonly" in self.attrib
	def readonly(self, value=True):
		"""set field as readonly; applicable to all fields"""
		if value:
			self.attrib["readonly"] = "readonly"
		elif self._readonly():
			del self.attrib["readonly"]
		return self
	############ prerender-callbacks ###########
	def _element_hint(self, parent_element):
		# handle hint - outsourced to be used in FieldGroup.__element__()
		if self._hint not in (None,""): # jquery-validation requires formHint to exist, even if empty
			p = etree.Element("p", {"class":"formHint"})
			p.text = self._hint
			parent_element.append(p)
	def __element__(self, formobj):
		# handle div, label, error; delegate hint to _element_hint()
		# _element() and _init(): both overridden by subclasses
		divattrib = {"class":"ctrlHolder"}
		if self._has_error(formobj):
			divattrib["class"] += " error"
		div = etree.Element("div", divattrib)
		label = etree.Element("label")
		# left: <label for="1">Afghanistan</label><input type="radio" id=1/>
		# right: <label><input type="radio"/> Afghanistan</input></label>
		# idea: only set "id" if "for" is needed (name or value for radio)
		subelelement = self._element(formobj)
		if self.labelleft:
			if self.attrib.get("id","") == "": # as "for" is set, "id" must be set, too
				self.attrib["id"] = self._name
			label.attrib["for"] = self.attrib["id"]
			label.text = self.labelstr + ":"
			div.extend([label, subelelement])
		else:
			element = subelelement
			element.tail = " " + self.labelstr
			label.append(element)
			div.append(label)
		self._element_hint(div)
		return div
	def _element(self, formobj):
		# return specific element, e.g. <input/>
		raise NotImplementedError(self.__class__.__name__)
	def _init(self):
		"""
		as this method shall be overridden instead of __init__(), thus attributes may get adjusted here
		intended to be overidden by subclass, some may want to overwrite at least self.attrib["type"]
		this method should be called from all render() and _element() methods of all subclasses (except HiddenField)
		# CALLED BY bind_form()
		"""
		raise NotImplementedError(self.__class__.__name__)

#class NullField(_Field): # This class can be used to define a Column or an existing Field not to be rendered

class TextField(_Field):
	#_inputtype =  # classes that derive from TextField will differ in that, e.g. "password" for PasswordField
	#def __init__(self, column = None, **attributes):
	"""adds standard form fields to the internal dict of fields
		it can be used as convinience class to convert subclasses to default Field objects
		parameter usage:
		column:		object of Column or other Field object to convert (None to disable self-validation)
		value:		only provided, if sql-functionality is waived: to avoid filling the field
					with sql-values(or sql beeing not used at all), just set value at least to ''
		name:		the name of the field, name will be set to id, if not otherwise specified
	both id and name will be set either to field identifier in Formular or through attributes"""
	def _init(self):
		# some subclasses only differ in their "type"-string
		# overwrite this method to preset type of input fields
		self.attrib["type"] = "text"
		self.attrib["class"] = "textInput" # uni-form specific
	def _element(self, formobj):
		if self._has_error(formobj):
			self.append_css("error")
		value = self._value_str(formobj)
		if value != "":
			self.attrib["value"] = value
		return etree.Element("input", self.attrib)

class PasswordField(TextField):
	"""just a plain input-field with type="password", usually the use of PasswordFieldGroup is appreciated"""
	_validators = [] # will be added in PasswordFieldGroup - or manually
	def _init(self):
		self.attrib["type"] = "password"
		self.attrib["class"] = "textInput" # uni-form specific
	def _value_str(self, formobj):
		return ""

class EmailField(TextField):
	_validators = [validators.validateEmail()]
	def _init(self):
		self.attrib["type"] = "email"
		self.attrib["class"] = "textInput" # uni-form specific
	#def clean(self, value):
	#	# TODO: trim whitespaces (and caps) from user input
	#	# TextField.value(self,v.strip().lower()) # clean() might/should do that!

class IntegerField(TextField):
	_validators = [validators.validateInteger()]
	def _init(self):
		self.attrib["type"] = "number"
		self.attrib["class"] = "textInput small" # uni-form specific

class TimeField(TextField):
	def _init(self):
		self.attrib["type"] = "time"
		self.attrib["class"] = "textInput small" # uni-form specific

class DateField(TextField):
	def _init(self):
		self.attrib["type"] = "date"
		self.attrib["class"] = "textInput small" # uni-form specific

class DatetimeField(TextField):
	def _init(self):
		self.attrib["type"] = "datetime"
		self.attrib["class"] = "textInput medium" # uni-form specific

class HiddenField(_Field):
	_handled_by_fieldset = False
	def _value_py(self, formobj):
		if "value" in self.attrib:
			# will be unaffected by clean()
			return self.attrib["value"]
		return _Field._value_py(self, formobj)
	def __element__(self, formobj):
		# override __element__() alltogether, thus skipping all unneeded steps
		# note: values set via attrib are taken preferably
		tmp_attrib = {
			"type" : "hidden",
			"value" : self._value_str(formobj),
			"name" : self._name
		}
		return etree.Element("input", tmp_attrib)

class TextArea(TextField):
	"""renders field as textarea, use cols and rows to specify for it's size"""
	#multiline = True # this is the case where this is needed -> maybe replaced by type(field/column).__name__ entirely!
	def cols(self, cols=20):
		self.attrib["cols"] = cols
		return self
	def rows(self, rows=20):
		self.attrib["rows"] = rows
		return self
	def _element(self, formobj):
		if self._has_error(formobj):
			self.append_css("error")
		field = etree.Element("textarea", self.attrib)
		field.text = self._value_str(formobj)
		return field

class ComboBox(_Field):
	"""adds a <select> field, putting all fields from options in an <option> tag."""
	def _value_str(self, anyobj):
		# note: takes the actual value instead of a formobj
		# sync Changes with _Field._value_str()
		if self._column is not None:
			return self._column._prepare_value(anyobj)
		return str(anyobj)
	def _init(self):
		pass
	def _element(self, formobj):
		field = etree.Element("select", self.attrib)
		globalvalue = self._value_py(formobj)
		found = globalvalue is None # don't even try to find out which to select, if value is None
		for label, tmpvalue in self._options().iteritems():
			odict = {"value": self._value_str(tmpvalue)} #bool:"1"/""
			# will not work if clean() didn't work properly; may contain None
			assert found or type(tmpvalue) == type(globalvalue)
			if not found and tmpvalue == globalvalue:
				odict["selected"] = "selected"
				found = True
			option = etree.SubElement(field, "option", odict)
			option.text = unicode(str(label), "utf-8") #bool:"yes"/"no"
		if not found: # and required not in self._validators
			field.insert(0, etree.Element("option", {"value":""}))
		return field

class List(ComboBox): # http://demo.qooxdoo.org/current/showcase/#form
	def rows(self, rows=20): # shall that default to the number of self._options()??
		"""
		note that this is a variant of ComboBox (which means <select> html-tag)
		where the relevant attribute is named size -> defaults to number of options in self._options()
		"""
		self.attrib["size"] = rows
		return self
	def _init(self):
		ComboBox._init(self)
		if "size" not in self.attrib:
			self.attrib["size"] = len(self._options())

###########################################################################
######################## MultipleField FTW ################################
######################################################################## */

# like FieldSet
# - one column is assigned for FieldGroup, several for FieldSet
# - FieldGroup has several sub-fields, EVENTUALLY several values (FieldSet:both)
# - 1 label on the left(FieldSet:top), several for each sub-field above
# - FieldSet can have FieldSets/FieldGroups as children

# Form: (DONE)
# - subclass of FieldSet (inherits __element__())
# - holds values of all child-FieldSets/FieldGroups
# - holds fields " (copies, needed)
# renders all hidden-fields and all fields that are no FieldSet/FieldGroup
# calls __element__(), validate() of all child-FieldSets/FieldGroups
# => FieldSet does exactly that (!!) for its own child-FieldSets/FieldGroups

# need a way to synchronize FieldSet._fields with Form._fields / _all_fields


# TODO: consider DateGroup, DateTimeGroup
# this has much in common with FieldSet, maybe share some??
# common scnenario: choose between FieldSet and FieldGroup / e.g. rendering differently

class FieldGroup(_Field, FieldSet):
	# note, that a FieldFroup still represents one column,
	# thus FieldSet has a very different Use-Case
	## Subclasses usually only need to override _init()
	def __init__(self, column = None, **attrib):
		_Field.__init__(self, column, **attrib)
		FieldSet.__init__(self)
		self._fields = [] # would use class-wide attribute, instead (not threadsave)
		self._is_vertical = False
	def _fgfields(self, formobj):
		# __element__() shall access sub-fields through this method,
		# as RadioButtonGroup will have a different set of options for
		# each request (to be overridden by any class that need thread-safety)
		return self._fields
	def clean(self, formobj):
		return FieldSet.clean(self, formobj)
	def bind_form(self, formcls):
		# both _Field.bind_form() and BieldSet.bind_form() must
		# be called in the right order
		_Field.bind_form(self, formcls)
		FieldSet.bind_form(self, formcls)
		return self
	def horizontal(self):
		self._is_vertical = False
	def vertical(self):
		self._is_vertical = True
	def __element__(self, formobj):
		# a error within fieldgroup-scope makes everything go red
		# it would be a mess to handle this otherwise:
		# it would require nasty api changes and quite some overhead
		divattrib = {"class":"ctrlHolder"}
		if self.labelstr == "":
			divattrib["class"] += " noLabel"
		if self._has_error(formobj):
			divattrib["class"] += " error"
		div = etree.Element("div", divattrib)
		# GLOBAL label, not to be confused with each element's label,
		# which is handled by _Field._element_label()
		if self.labelstr not in (None,""): # only if labelleft(?)
			label = etree.Element("p", {"class":"label"})
			label.text = self.labelstr + ":"
			div.append(label)
		# Uni-Form does it with lists
		ul = etree.Element("ul")
		if self._is_vertical:
			ul.attrib["class"] = "alternate"
		for field in self._fgfields(formobj):
			li = etree.Element("li")
			element = field._element(formobj)
			# within <li></li>, the field must be always inside the label-tag
			# left: <label>Afghanistan <input type="radio"/></label>
			# right: <label><input type="radio"/> Afghanistan</input></label>
			label = etree.Element("label")
			if field.labelleft: # no "for", here!
				label.text = field.labelstr + ": "
			else:
				element.tail = " " + field.labelstr
			label.append(element)
			li.append(label)
			ul.append(li)
		div.append(ul)
		self._element_hint(div) # only one per FieldGroup
		return div

class PasswordFieldGroup(FieldGroup):
	# ChangePasswordField, InsertPasswordField, AdminPasswordField
	# CON: DateTimeFieldGroup having 3 fields: date,month,yearn ("clean" puts it together)
	"""
	HOW STRONG:
	4 balken/vierecke:
		- enthält sowohl groß- als auch kleinbuchstaben
		- enthält sowohl zahlen als auch buchstaben
		- ist länger als 6 zeichen
		- ist länger als 8 zeichen
		hint: Use letters and numbers and mix lower and uppercase
		rot/1: warnen, weil zu kurz / too short (nicht erlauben)
		gelb/2: warnen, weil schwach / week (erlauben)
		grün/3: ok
		grün/4: secure
	-> nicht erlauben: kürzer als 6 zeichen, gleiches wie name/id
	"""
	_label_old = "Old Password"
	_label_new = "New Password"
	_label_generate = "generate"
	_label_confirm = "Re-type Password"
	_fieldname_old = "old"
	_fieldname_generate = "generatepw"
	_fieldname_confirm = "confirm"
	def validate(self, formobj):
		return FieldSet.validate(self, formobj)
	def _init(self):
		# one field MUST have the proper name corresponding to self._column
		# this is relied on, when the results get assigned to the fields!
		fieldname_new = self.attrib.get("name", self._column._name) # fallback to column-name
		new = PasswordField(column=self._column, name=fieldname_new)
		new.label(self._label_new)
		#if False and "admin": SHOULD BE AN EXTRA SUBCLASS, THUS EASIER TO UNDERSTAND
		#	generate = CheckBox(name=self._fieldname_generate).label(self._label_generate).label_right()
		# only "new" password shall be required to enforce min-length (in case of minlength gets changed!)
		if self._form._bound_to_update:
			# it is not required to enter anything
			old = PasswordField(column=self._column, name=self._fieldname_old)
			old.label(self._label_old)
			self.append_fields(old)
			formclscmd = self._form.__command__
			tselectcmd = formclscmd.dbo._adapter.Select(formclscmd)
			tselectcmd.columns(self._column)
			## that validator shall only take effect, if "new password" was not left blank
			## -> should be a more custom validator, e.g. validateCallback
			# how to do that if required was NOT in place
			old.append_validators(validators.SelectValidator(tselectcmd))
		else:
			# it is required to enter something in both fields
			pass
		confirm = PasswordField(column=self._column, name=self._fieldname_confirm)
		confirm.label(self._label_confirm) # Password confirmation
		confirm.append_validators(validators.validateSameAs(new))
		new.append_validators(validators.validateMinLength(6)) # TODO: retrieve min-length from column
		self.append_fields(new, confirm)
	#def __element__(self, formobj): # it actually works!!
	#	return FieldSet.__element__(self, formobj)

class _CheckBox(_Field):
	def _init(self):
		self.attrib["type"] = "checkbox"
		self.label_right()
	def _element(self, formobj):
		# the only thing that is handled is the "checked"-attribute - setting
		# the value attribute would vanish any effect of the checkbox
		if bool(self._value_py(formobj)):
			self.attrib["checked"] = "checked"
		return etree.Element("input", self.attrib)

class CheckBox(FieldGroup):
	# CheckBox forwards everything to a single _ChechBox object
	# this is implemented as FieldGroup because it is the easiest way
	# to implement, it shouldn't be relevant at all when using it
	def clean(self, formobj):
		pass
	def _init(self):
		field = _CheckBox(self._column, **self.attrib).label(self.labelstr)
		self.append_fields(field)
		self.labelstr = "" # avoid double labels, maybe handle otherwise??

class _RadioButton(_Field):
	"""this is just a conveniance-class for RadioButtonGroup, shall not be used otherwise"""
	# def _init(self): won't be called, as bind_form() doesn't get called either
	def _element(self, formobj):
		# errors are ignored here, there should be no error for single radiobutton
		# only RadioButtonGroup handles the "checked" and "value" attributes
		# _element() is called only once before the _RadioButton gets garbage-collected
		self.attrib["type"] = "radio"
		return etree.Element("input", self.attrib)

class RadioButtonGroup(FieldGroup):
	"""while a single _RadioButton uses name as groupname, id is used here as the group identifier"""
	def _fgfields(self, formobj):
		# RadioButtonGroup can never rely on FieldGroup._fields, as each
		# _RadioButton is generated for every request (for thread-safety reasons)
		# thus every formobj stores fieldgroup_name:_fields[] assertions
		return formobj._temporary_fields[self._name]
	def append_fields(self, *fields):
		raise Exception("can't use RadioButtonGroup.append_fields(): no access to formobj")
	def clean(self, formobj):
		# must not call FieldGroup.clean(), as _fields will always be empty
		_Field.clean(self, formobj)
	def _value_str(self, anyobj):
		# sync Changes with ComboBox._value_str()
		if self._column is not None:
			return self._column._prepare_value(anyobj)
		return str(anyobj)
	def _init(self):
		pass
	def _rbgroup_prepare(self, formobj):
		# to be able to compare global_value and value_per_field, they must be of the same type
		_tf = [] # store for temporary-fields
		group_name = self._name # fallback to column-name
		globalvalue = self._value_py(formobj)
		for label, tmpvalue in self._options().iteritems():
			assert globalvalue is None or type(tmpvalue) == type(globalvalue)
			tmpfield = _RadioButton(name=group_name, type="radio")
			tmpfield.label(str(label)).label_right()
			if tmpvalue == globalvalue:
				tmpfield.attrib["checked"] = "checked"
			tmpfield.attrib["value"] = self._value_str(tmpvalue) # bool:"1"/""
			_tf.append(tmpfield)
		formobj._temporary_fields[self._name] = _tf
		return _tf
	def __element__(self, formobj):
		# each _RadioButton object will be created once per request
		# functionality moved to _rbgroup_prepare(), as one might want to
		# access _temporary_fields otherwise than via FieldGroup.__element__()
		self._rbgroup_prepare(self, formobj)
		return FieldGroup.__element__(self,formobj)

###########################################################################
######################## Apply / Cancel BTN ###############################
######################################################################## */

class SubmitButton(_Field):
	_handled_by_fieldset = False
	labelstr = property(
		fget=lambda self:self.attrib.get("value",""),
		fset=lambda self,value:self.attrib.__setitem__("value",value),
		doc="labelstr property is internally handled as part of attrib"
	)
	def __init__(self, **attrib):
		self._instantiation_count = _Field._instantiation_count # held actual value locally
		_Field._instantiation_count += 1 # increment class-wide attribute for next instantiation
		self.attrib = attrib
	def __element__(self, formobj):
		self.attrib.update({"type":"submit", "class":"primaryAction"})
		return etree.Element("input", self.attrib)

###########################################################################
###################### Other, Special Fields ##############################
######################################################################## */

# Spinner and Slider require upper- and lowerlimit been set (which shall be also the case in case of self.__optionsobj == None?)
# class Spinner(IntegerField): # dropped in favor of IntegerField / FloatField / etc

class Slider(IntegerField):
	"""requires min and max to be set"""
	def _init(self):
		if self._column is None or self._column.min is None or self._column.max is None:
			raise Exception(type(self).__name__ + " requires min and max to be set (within BaseColmn)")
		self.attrib["type"] = "range"
